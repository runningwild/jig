// Code generated by protoc-gen-go. DO NOT EDIT.
// source: github.com/runningwild/jig/proto/jig.proto

/*
Package jig is a generated protocol buffer package.

It is generated from these files:
	github.com/runningwild/jig/proto/jig.proto

It has these top-level messages:
	Repo
	Node
	Edge
	Commit
	EdgeRef
	NewContent
	NodeRef
*/
package jig

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion2 // please upgrade the proto package

type Form int32

const (
	Form_Unknown Form = 0
	Form_Src     Form = 1
	Form_Snk     Form = 2
	Form_Text    Form = 3
)

var Form_name = map[int32]string{
	0: "Unknown",
	1: "Src",
	2: "Snk",
	3: "Text",
}
var Form_value = map[string]int32{
	"Unknown": 0,
	"Src":     1,
	"Snk":     2,
	"Text":    3,
}

func (x Form) String() string {
	return proto.EnumName(Form_name, int32(x))
}
func (Form) EnumDescriptor() ([]byte, []int) { return fileDescriptor0, []int{0} }

type Repo struct {
}

func (m *Repo) Reset()                    { *m = Repo{} }
func (m *Repo) String() string            { return proto.CompactTextString(m) }
func (*Repo) ProtoMessage()               {}
func (*Repo) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{0} }

// Node contains POD.  All of the edge data is embedded so that they can be split when necessary.
// When a Node splits, we get two nodes whose Form, Content, and Count are determined in the obvious
// way.  The first in the pair gets the In edges and an Out edge to the second in the pair, the last
// gets the Out edges and an In edge to the first in the pair.
type Node struct {
	// Head is the hash of the first true node in this Node.  Whenever this Node is split, the head
	// hash will never change.
	Head string `protobuf:"bytes,1,opt,name=head" json:"head,omitempty"`
	// Tail is the hash of the last true node in this Node.  If Count == 1 it will always equal
	// Head, otherwise any time this Node is split, the second Node created will implicitly
	// inherit the value of Tail prior to the split.
	Tail string `protobuf:"bytes,2,opt,name=tail" json:"tail,omitempty"`
	Form Form   `protobuf:"varint,3,opt,name=form,enum=jig.Form" json:"form,omitempty"`
	// Hash of the content, not the content itself.
	Content string `protobuf:"bytes,4,opt,name=content" json:"content,omitempty"`
	// Number of internal nodes represented by this Node.
	Count int32   `protobuf:"varint,5,opt,name=count" json:"count,omitempty"`
	In    []*Edge `protobuf:"bytes,6,rep,name=in" json:"in,omitempty"`
	Out   []*Edge `protobuf:"bytes,7,rep,name=out" json:"out,omitempty"`
}

func (m *Node) Reset()                    { *m = Node{} }
func (m *Node) String() string            { return proto.CompactTextString(m) }
func (*Node) ProtoMessage()               {}
func (*Node) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{1} }

func (m *Node) GetHead() string {
	if m != nil {
		return m.Head
	}
	return ""
}

func (m *Node) GetTail() string {
	if m != nil {
		return m.Tail
	}
	return ""
}

func (m *Node) GetForm() Form {
	if m != nil {
		return m.Form
	}
	return Form_Unknown
}

func (m *Node) GetContent() string {
	if m != nil {
		return m.Content
	}
	return ""
}

func (m *Node) GetCount() int32 {
	if m != nil {
		return m.Count
	}
	return 0
}

func (m *Node) GetIn() []*Edge {
	if m != nil {
		return m.In
	}
	return nil
}

func (m *Node) GetOut() []*Edge {
	if m != nil {
		return m.Out
	}
	return nil
}

type Edge struct {
	Commit string `protobuf:"bytes,1,opt,name=commit" json:"commit,omitempty"`
	// There are two special values for output node hashes.
	// If this edge is coming from a file node:
	// "0": The file has been deleted
	// If this edge is coming from an internal node:
	// "1": This is the end of the file.
	Node string `protobuf:"bytes,2,opt,name=node" json:"node,omitempty"`
	// Join indicates that an edge continues through a node.  If the In and Out edges from a commit
	// are Join Edges then it is as though there is an edge from this commit between each adjacent
	// pair of nodes within the greater Node.
	Join bool `protobuf:"varint,3,opt,name=join" json:"join,omitempty"`
}

func (m *Edge) Reset()                    { *m = Edge{} }
func (m *Edge) String() string            { return proto.CompactTextString(m) }
func (*Edge) ProtoMessage()               {}
func (*Edge) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{2} }

func (m *Edge) GetCommit() string {
	if m != nil {
		return m.Commit
	}
	return ""
}

func (m *Edge) GetNode() string {
	if m != nil {
		return m.Node
	}
	return ""
}

func (m *Edge) GetJoin() bool {
	if m != nil {
		return m.Join
	}
	return false
}

type Commit struct {
	Deps     []string   `protobuf:"bytes,1,rep,name=deps" json:"deps,omitempty"`
	EdgeRefs []*EdgeRef `protobuf:"bytes,2,rep,name=edge_refs" json:"edge_refs,omitempty"`
}

func (m *Commit) Reset()                    { *m = Commit{} }
func (m *Commit) String() string            { return proto.CompactTextString(m) }
func (*Commit) ProtoMessage()               {}
func (*Commit) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{3} }

func (m *Commit) GetDeps() []string {
	if m != nil {
		return m.Deps
	}
	return nil
}

func (m *Commit) GetEdgeRefs() []*EdgeRef {
	if m != nil {
		return m.EdgeRefs
	}
	return nil
}

type EdgeRef struct {
	Src *NodeRef `protobuf:"bytes,1,opt,name=src" json:"src,omitempty"`
	Dst *NodeRef `protobuf:"bytes,2,opt,name=dst" json:"dst,omitempty"`
	// Content inserted between Src and Dst.  This can be nil, in which case the edge created by
	// this EdgeRef connects Src directly to Dst.
	Content *NewContent `protobuf:"bytes,3,opt,name=content" json:"content,omitempty"`
}

func (m *EdgeRef) Reset()                    { *m = EdgeRef{} }
func (m *EdgeRef) String() string            { return proto.CompactTextString(m) }
func (*EdgeRef) ProtoMessage()               {}
func (*EdgeRef) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{4} }

func (m *EdgeRef) GetSrc() *NodeRef {
	if m != nil {
		return m.Src
	}
	return nil
}

func (m *EdgeRef) GetDst() *NodeRef {
	if m != nil {
		return m.Dst
	}
	return nil
}

func (m *EdgeRef) GetContent() *NewContent {
	if m != nil {
		return m.Content
	}
	return nil
}

type NewContent struct {
	Form    Form     `protobuf:"varint,1,opt,name=form,enum=jig.Form" json:"form,omitempty"`
	Content [][]byte `protobuf:"bytes,2,rep,name=content,proto3" json:"content,omitempty"`
}

func (m *NewContent) Reset()                    { *m = NewContent{} }
func (m *NewContent) String() string            { return proto.CompactTextString(m) }
func (*NewContent) ProtoMessage()               {}
func (*NewContent) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{5} }

func (m *NewContent) GetForm() Form {
	if m != nil {
		return m.Form
	}
	return Form_Unknown
}

func (m *NewContent) GetContent() [][]byte {
	if m != nil {
		return m.Content
	}
	return nil
}

type NodeRef struct {
	// Typical hash of the node that this NodeRef refers to.  This may also refer to nodes that are
	// created by this commit.
	Node string `protobuf:"bytes,1,opt,name=node" json:"node,omitempty"`
	// Depth indicates how many nodes should be used before inserting the edge in question.  For
	// example, if there are nodes connected like A -> B -> C and a src node specifies node A with
	// depth 2, that refers to an outgoing edge B, but a dst node that specifies node A with depth 2
	// is referring to an incoming edge into C.  Because of this a src node must specify Depth >= 1,
	// a dst node must specify Depth >= 0.
	Depth int32 `protobuf:"varint,2,opt,name=depth" json:"depth,omitempty"`
	Join  bool  `protobuf:"varint,3,opt,name=join" json:"join,omitempty"`
}

func (m *NodeRef) Reset()                    { *m = NodeRef{} }
func (m *NodeRef) String() string            { return proto.CompactTextString(m) }
func (*NodeRef) ProtoMessage()               {}
func (*NodeRef) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{6} }

func (m *NodeRef) GetNode() string {
	if m != nil {
		return m.Node
	}
	return ""
}

func (m *NodeRef) GetDepth() int32 {
	if m != nil {
		return m.Depth
	}
	return 0
}

func (m *NodeRef) GetJoin() bool {
	if m != nil {
		return m.Join
	}
	return false
}

func init() {
	proto.RegisterType((*Repo)(nil), "jig.Repo")
	proto.RegisterType((*Node)(nil), "jig.Node")
	proto.RegisterType((*Edge)(nil), "jig.Edge")
	proto.RegisterType((*Commit)(nil), "jig.Commit")
	proto.RegisterType((*EdgeRef)(nil), "jig.EdgeRef")
	proto.RegisterType((*NewContent)(nil), "jig.NewContent")
	proto.RegisterType((*NodeRef)(nil), "jig.NodeRef")
	proto.RegisterEnum("jig.Form", Form_name, Form_value)
}

func init() { proto.RegisterFile("github.com/runningwild/jig/proto/jig.proto", fileDescriptor0) }

var fileDescriptor0 = []byte{
	// 357 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x7c, 0x52, 0xc1, 0x6e, 0xe2, 0x30,
	0x10, 0x5d, 0xc7, 0x4e, 0x42, 0x86, 0x2c, 0x44, 0x96, 0x76, 0xd7, 0x7b, 0xda, 0x28, 0xa7, 0x88,
	0x03, 0x91, 0xd8, 0xd5, 0xf6, 0x03, 0x50, 0x7b, 0xec, 0x81, 0xb6, 0xe7, 0x0a, 0x62, 0x13, 0x0c,
	0xc4, 0x8e, 0x12, 0x47, 0xf4, 0x1b, 0xfa, 0xd5, 0x55, 0x4c, 0x02, 0x2a, 0x87, 0xde, 0xde, 0xcc,
	0x1b, 0xcf, 0x7b, 0xf3, 0x64, 0x98, 0x15, 0xd2, 0xec, 0xda, 0xcd, 0x3c, 0xd7, 0x65, 0x56, 0xb7,
	0x4a, 0x49, 0x55, 0x9c, 0xe4, 0x91, 0x67, 0x7b, 0x59, 0x64, 0x55, 0xad, 0x8d, 0xee, 0xd0, 0xdc,
	0x22, 0x8a, 0xf7, 0xb2, 0x48, 0x3c, 0x20, 0x2b, 0x51, 0xe9, 0xe4, 0x1d, 0x01, 0x79, 0xd4, 0x5c,
	0xd0, 0x10, 0xc8, 0x4e, 0xac, 0x39, 0x43, 0x31, 0x4a, 0x83, 0xae, 0x32, 0x6b, 0x79, 0x64, 0x8e,
	0xad, 0x7e, 0x01, 0xd9, 0xea, 0xba, 0x64, 0x38, 0x46, 0xe9, 0x64, 0x11, 0xcc, 0xbb, 0x5d, 0x0f,
	0xba, 0x2e, 0xe9, 0x14, 0xfc, 0x5c, 0x2b, 0x23, 0x94, 0x61, 0xc4, 0x4e, 0x7e, 0x07, 0x37, 0xd7,
	0xad, 0x32, 0xcc, 0x8d, 0x51, 0xea, 0xd2, 0x1f, 0xe0, 0x48, 0xc5, 0xbc, 0x18, 0xa7, 0xe3, 0xfe,
	0xd9, 0x3d, 0x2f, 0x04, 0xfd, 0x09, 0x58, 0xb7, 0x86, 0xf9, 0x37, 0xfd, 0x64, 0x01, 0xc4, 0xf2,
	0x13, 0xf0, 0x72, 0x5d, 0x96, 0xd2, 0x5c, 0xdd, 0x28, 0xcd, 0x45, 0xef, 0x26, 0x04, 0xb2, 0xd7,
	0x52, 0x59, 0x37, 0xa3, 0xe4, 0x0e, 0xbc, 0xa5, 0x9d, 0xed, 0xfa, 0x5c, 0x54, 0x0d, 0x43, 0x31,
	0x4e, 0x03, 0xfa, 0x07, 0x02, 0xc1, 0x0b, 0xf1, 0x5a, 0x8b, 0x6d, 0xc3, 0x1c, 0xab, 0x14, 0x5e,
	0x94, 0x56, 0x62, 0x9b, 0xac, 0xc1, 0xef, 0x21, 0xfd, 0x0d, 0xb8, 0xa9, 0x73, 0x2b, 0x36, 0x4c,
	0x75, 0x99, 0xf4, 0x14, 0x6f, 0x8c, 0x55, 0xbe, 0xa5, 0xe2, 0xeb, 0xf1, 0xd8, 0xd2, 0xd3, 0x33,
	0x2d, 0x4e, 0xcb, 0x73, 0x3b, 0xf9, 0x0f, 0x70, 0xad, 0x2e, 0x29, 0xa2, 0x2f, 0x52, 0xec, 0x8c,
	0x86, 0xc9, 0x3f, 0xf0, 0x07, 0x91, 0xe1, 0x74, 0x34, 0xc4, 0xcb, 0x45, 0x65, 0x76, 0xd6, 0x8f,
	0xfb, 0x39, 0x89, 0x59, 0x06, 0xc4, 0xae, 0x1b, 0x83, 0xff, 0xa2, 0x0e, 0x4a, 0x9f, 0x54, 0xf4,
	0x8d, 0xfa, 0x80, 0x9f, 0xea, 0x3c, 0x42, 0x16, 0xa8, 0x43, 0xe4, 0xd0, 0x11, 0x90, 0x67, 0xf1,
	0x66, 0x22, 0xbc, 0xf1, 0xec, 0x7f, 0xf8, 0xfb, 0x11, 0x00, 0x00, 0xff, 0xff, 0x10, 0xe5, 0xed,
	0x82, 0x3d, 0x02, 0x00, 0x00,
}
